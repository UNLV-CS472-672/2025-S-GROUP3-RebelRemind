import { useEffect, useState } from "react";
import "./css/UserEvents.css";

/**
 * UserEventList Component
 *
 * Displays a list of user-created events retrieved from Chrome local storage.
 * Supports:
 *  - Tabs for viewing Upcoming and Past events
 *  - Expandable dropdown UI per event
 *  - Editing and deleting events
 *  - Automatic updates via `chrome.runtime.onMessage` (e.g. after creating a new event)
 * 
 * Authored by: Sebastian Yepez
 * Documentation generated by ChatGPT
 * 
 */
const UserEventList = () => {
    const [userEvents, setUserEvents] = useState([]);
    const [expandedEventKey, setExpandedEventKey] = useState(null); // Tracks expanded dropdown
    const [activeTab, setActiveTab] = useState("upcoming"); // "upcoming" or "past"
    const [editingKey, setEditingKey] = useState(null); // Currently editing dropdown
    const [editedEvent, setEditedEvent] = useState({}); // Editable event state

    /**
     * Loads all user-defined events from Chrome local storage on mount,
     * and subscribes to runtime messages for real-time syncing.
     */
    useEffect(() => {
        const loadEvents = () => {
            chrome.storage.local.get("userEvents", (data) => {
                if (Array.isArray(data["userEvents"])) {
                    setUserEvents(data["userEvents"]);
                }
            });
        };

        loadEvents();

        const handleMessage = (message) => {
            if (message.type === "EVENT_CREATED") {
                console.log("ðŸ” Reloading from background after event update...");
                loadEvents();
            }
        };

        chrome.runtime.onMessage.addListener(handleMessage);
        return () => chrome.runtime.onMessage.removeListener(handleMessage);
    }, []);

    /**
     * Deletes a single event from local storage and state.
     */
    const handleDelete = (indexToDelete) => {
        const updatedEvents = userEvents.filter((_, i) => i !== indexToDelete);
        chrome.storage.local.set({ "userEvents": updatedEvents }, () => {
            setUserEvents(updatedEvents);
            setExpandedEventKey(null);
            chrome.runtime.sendMessage({ type: "EVENT_UPDATED" });
        });
    };

    /**
     * Expands or collapses a given event's dropdown.
     */
    const toggleExpand = (key) => {
        setExpandedEventKey(prev => prev === key ? null : key);
    };

    /**
     * Converts 24hr time (HH:MM) to 12hr format with am/pm.
     */
    const formatTime12hr = (timeString) => {
        if (!timeString) return "";
        const [hour, minute] = timeString.split(":").map(Number);
        const ampm = hour >= 12 ? "pm" : "am";
        const hr = hour % 12 || 12;
        return `${hr}:${minute.toString().padStart(2, "0")} ${ampm}`;
    };

    /**
     * Safely parses a YYYY-MM-DD string into a local Date object.
     */
    const parseDateLocal = (yyyyMmDd) => {
        const [year, month, day] = yyyyMmDd.split("-").map(Number);
        return new Date(year, month - 1, day);
    };

    /**
     * Converts a date string into a readable format (e.g. March 25, 2025).
     */
    const formatDate = (dateString) => {
        if (!dateString) return "";
        const date = parseDateLocal(dateString);
        return date.toLocaleDateString("en-US", {
            year: "numeric",
            month: "long",
            day: "numeric",
        });
    };

    /**
     * Returns a Date object for the event including time if available.
     */
    const getEventDateTime = (event) => {
        const date = parseDateLocal(event.startDate);
        if (!event.allDay && event.startTime) {
            const [h, m] = event.startTime.split(":").map(Number);
            date.setHours(h, m, 0, 0);
        } else {
            date.setHours(0, 0, 0, 0);
        }
        return date;
    };

    // Reference date representing "today" at midnight
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Classification helpers
    const isToday = (event) => {
        const date = parseDateLocal(event.startDate);
        date.setHours(0, 0, 0, 0);
        return date.getTime() === today.getTime();
    };

    const isFuture = (event) => {
        const date = parseDateLocal(event.startDate);
        date.setHours(0, 0, 0, 0);
        return date > today;
    };

    const isPast = (event) => {
        const date = parseDateLocal(event.startDate);
        date.setHours(0, 0, 0, 0);
        return date < today;
    };

    // Grouping and sorting
    const todayEvents = userEvents.filter(isToday).sort((a, b) => getEventDateTime(a) - getEventDateTime(b));
    const upcomingEvents = userEvents.filter(isFuture).sort((a, b) => getEventDateTime(a) - getEventDateTime(b));
    const pastEvents = userEvents.filter(isPast).sort((a, b) => getEventDateTime(b) - getEventDateTime(a));

    /**
     * Validates and saves an event after it's been edited.
     */
    const saveEdit = (originalEvent) => {
        const { title, startDate, startTime, endTime } = editedEvent;
        const isAllDay = !startTime?.trim() && !endTime?.trim();

        if (!title?.trim()) {
            alert("Please enter a valid title.");
            return;
        } else if (!startDate?.trim()) {
            alert("Please enter a date.");
            return;
        } else if (!isAllDay) {
            if (!startTime?.trim() && endTime?.trim()) {
                alert("Please enter a start time.");
                return;
            } else if (!endTime?.trim() && startTime?.trim()) {
                alert("Please enter an end time.");
                return;
            }
        }

        const index = userEvents.findIndex(e => e === originalEvent);
        if (index === -1) return;

        const updatedEvents = [...userEvents];
        updatedEvents[index] = {
            ...editedEvent,
            allDay: isAllDay,
        };

        chrome.storage.local.set({ "userEvents": updatedEvents }, () => {
            setUserEvents(updatedEvents);
            setEditingKey(null);
            setEditedEvent({});
            chrome.runtime.sendMessage({ type: "EVENT_UPDATED" });
        });
    };

    /**
     * Renders a single event as a dropdown item with optional edit mode.
     */
    const renderEvent = (event, index, section) => {
        const eventKey = `${section}-${index}`;

        return (
            <li key={eventKey} className="event-dropdown-item">
                <div className="event-dropdown-header" onClick={() => toggleExpand(eventKey)}>
                    <div className="dropdown-title">
                        <span className="dropdown-icon">
                            {expandedEventKey === eventKey ? "â–²" : "â–¼"}
                        </span>
                        <span>{event.title}</span>
                    </div>
                    <button
                        className="delete-btn"
                        onClick={(e) => {
                            e.stopPropagation();
                            const realIndex = userEvents.findIndex((e2) => e2 === event);
                            handleDelete(realIndex);
                        }}
                    >
                        Delete
                    </button>
                </div>

                {expandedEventKey === eventKey && (
                    <div className="event-dropdown-details">
                        {editingKey === eventKey ? (
                            <>
                                {/* Editable Fields */}
                                <div className="edit-row">
                                    <span className="edit-label">Title:</span>
                                    <input
                                        type="text"
                                        value={editedEvent.title || ""}
                                        onChange={(e) => setEditedEvent({ ...editedEvent, title: e.target.value })}
                                        className="edit-input"
                                    />
                                </div>
                                <div className="edit-row">
                                    <span className="edit-label">Date:</span>
                                    <input
                                        type="date"
                                        value={editedEvent.startDate || ""}
                                        onChange={(e) => setEditedEvent({ ...editedEvent, startDate: e.target.value })}
                                        className="edit-input"
                                    />
                                </div>
                                <div className="edit-row">
                                    <span className="edit-label">Start Time:</span>
                                    <input
                                        type="time"
                                        value={editedEvent.startTime || ""}
                                        onChange={(e) => setEditedEvent({ ...editedEvent, startTime: e.target.value })}
                                        className="edit-input"
                                    />
                                </div>
                                <div className="edit-row">
                                    <span className="edit-label">End Time:</span>
                                    <input
                                        type="time"
                                        value={editedEvent.endTime || ""}
                                        onChange={(e) => setEditedEvent({ ...editedEvent, endTime: e.target.value })}
                                        className="edit-input"
                                    />
                                </div>
                                <div className="edit-row">
                                    <span className="edit-label">Location:</span>
                                    <input
                                        type="text"
                                        value={editedEvent.location || ""}
                                        onChange={(e) => setEditedEvent({ ...editedEvent, location: e.target.value })}
                                        className="edit-input"
                                    />
                                </div>
                                <div className="edit-row">
                                    <span className="edit-label">Description:</span>
                                    <textarea
                                        className="edit-textarea"
                                        value={editedEvent.desc || ""}
                                        onChange={(e) => setEditedEvent({ ...editedEvent, desc: e.target.value })}
                                    />
                                </div>

                                {/* Save/Cancel Buttons */}
                                <div className="mt-3" style={{ display: "flex", gap: "10px", justifyContent: "center" }}>
                                    <button onClick={() => saveEdit(event)}>Save</button>
                                    <button onClick={() => setEditingKey(null)}>Cancel</button>
                                </div>
                            </>
                        ) : (
                            <>
                                {/* Read-Only View */}
                                <p><strong>Date:</strong> {formatDate(event.startDate) || "N/A"}</p>
                                <p><strong>Time:</strong> {event.allDay ? "All-day" : `${formatTime12hr(event.startTime)} - ${formatTime12hr(event.endTime)}`}</p>
                                <p><strong>Location:</strong> {event.location || "N/A"}</p>
                                <p><strong>Description:</strong> {event.desc || "No description."}</p>

                                <button onClick={() => {
                                    setEditingKey(eventKey);
                                    setEditedEvent({ ...event });
                                }}>
                                    Edit
                                </button>
                            </>
                        )}
                    </div>
                )}
            </li>
        );
    };

    return (
        <div className="mx-auto bg-white rounded shadow-md text-left" style={{ padding: "10px", marginTop: "10px" }}>
            <h3 className="text-xl font-semibold mb-2" style={{ marginTop: "10px" }}>Your Custom Events</h3>

            {/* Tab Switcher */}
            <div className="tab-nav">
                <div className={`tab-item ${activeTab === "upcoming" ? "active" : ""}`} onClick={() => setActiveTab("upcoming")}>Upcoming</div>
                <div className={`tab-item ${activeTab === "past" ? "active" : ""}`} onClick={() => setActiveTab("past")}>Past</div>
            </div>

            {/* Upcoming Tab */}
            {activeTab === "upcoming" && (
                <>
                    {todayEvents.length > 0 && (
                        <>
                            <h4 className="event-subheader mb-2">Today</h4>
                            <ul className="event-list">{todayEvents.map((event, index) => renderEvent(event, index, "today"))}</ul>
                        </>
                    )}
                    {upcomingEvents.length > 0 && (
                        <>
                            <h4 className="event-subheader mt-4 mb-2">Upcoming</h4>
                            <ul className="event-list">{upcomingEvents.map((event, index) => renderEvent(event, index, "upcoming"))}</ul>
                        </>
                    )}
                </>
            )}

            {/* Past Tab */}
            {activeTab === "past" && (
                <>
                    <h4 className="event-subheader mt-4 mb-2">All Past Events</h4>
                    <ul className="event-list">{pastEvents.map((event, index) => renderEvent(event, index, "past"))}</ul>
                </>
            )}
        </div>
    );
};

export default UserEventList;